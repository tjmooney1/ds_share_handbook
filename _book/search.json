[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science at SHARE Creative",
    "section": "",
    "text": "Preface to handbook\nThis section will provide an overview of this handbook.\n\nHandbook styling guide\nTimbo, we want this Handbook to appear written as a ‚ÄúDS Scientist at SHARE‚Äù rather than the Jimbo + Timbo show. To help streamline this, I suggest we follow the following guidelines to help ensure we are consistent with our writing style. Some of these points will not be relevant for all section, but I think we would be wise to always keep them in the back of our mind throughout:\n\nTone, we should be friendly but professional. We can definitely joke, but always try and make sure the point we are getting across is clear.\nLet‚Äôs make sure we use the active voice rather than passive voice and talk in the first person plural (i.e.¬†we, us rather than I, me etc).\nIf we are referring to a general data scientist or person, let‚Äôs be inclusive and refer to them as ‚Äúthey/them‚Äù. For example if we had the sentence ‚ÄúImagine a data scientist needs to embed a sentence, there are many models available on HuggingFace for them to choose from‚Äù.\nWe need to take responsibility for what we write (this will be more relevant in the later sections of the handbook). We need to be make sure we understand concepts before committing them to the handbook- the creation of this handbook will not only help any newcomer get on board quicker, but also help cement DS concepts ourselves.\n\n\n‚ÄúIf you can‚Äôt explain it simply, you don‚Äôt understand it well enough‚Äù - Albert Einstein",
    "crumbs": [
      "Preface to handbook"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1¬† Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. ‚ÄúLiterate Programming.‚Äù Comput. J. 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4¬† Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. ‚ÄúLiterate Programming.‚Äù Comput.\nJ. 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "index.html#handbook-styling-guide",
    "href": "index.html#handbook-styling-guide",
    "title": "Data Science at SHARE Creative",
    "section": "Handbook styling guide",
    "text": "Handbook styling guide",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "ai_landscape_workflow.html",
    "href": "ai_landscape_workflow.html",
    "title": "3¬† AI landscape",
    "section": "",
    "text": "Timbo use this qmd to write everything you need for the AI landscape.\n\n3.0.1 Background of project\nExplain here why Microsoft wanted to perform the project, and the overall goal of the project.\n\n\n3.0.2 Final output of project\nCouple of images of the landscape perhaps- with a summary outlining what was found (don‚Äôt worry about specific project details, something like ‚Äúdistinct topics of conversation found by human interpretation of the landscape‚Äù is better than ‚Äúin 726 we found 15 new topics of which conversational AI evolved to encompass the ethics topic‚Äù which is too specific)\n\n\n3.0.3 How to get there\nGo through a step by step approach as to how one would go about the project. For now, again don‚Äôt worry about details (etc I wouldn‚Äôt worry about the particular embedding model here, just say that the posts were embedded using a sentence transformer model etc).\nFeel free to add screenshots of things where needed",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>AI landscape</span>"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html",
    "href": "peaks_pits_workflow.html",
    "title": "Peaks and Pits",
    "section": "",
    "text": "What is the concept/project background?\nStrong memories associated to brands or products go deeper than simple positive or negative sentiment. In their book ‚ÄúThe Power of Moments‚Äù, two psychologists (Chip and Dan Heath) define these core memories as Peak and Pits, impactful experiences in our lives.\nBroadly, peak moments are experiences that stand our memorable in our lives in a positive sense, whereas pit moments are impactful negative experiences.\nMicrosoft tasked us with finding a way to identify these moments in social data- going beyond ‚Äòsimple‚Äô positive and negative sentiment which does not tell the full story of consumer/user experience. The end goal is that by providing Microsoft with these peak and pit moments in the customer experience, they can design peak moments in addition to simply removing pit moments.",
    "crumbs": [
      "Peaks and Pits"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html#what-is-the-concept",
    "href": "peaks_pits_workflow.html#what-is-the-concept",
    "title": "Peaks and Pits",
    "section": "",
    "text": "The end goal\nWith these projects the core final ‚Äòproduct‚Äô is a collection of different peaks and pits, with suitable representative verbatims and an explanation to understand the high-level intricacies of these different emotional moments.\n\n\n\nScreenshot from a Peaks and Pits project showcasing the identified Peak moments for a product at a high level\n\n\n\n\nKey aspects of project\n\nLimited data\nWell defined research problem and classes",
    "crumbs": [
      "Peaks and Pits"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html#overview-of-approach",
    "href": "peaks_pits_workflow.html#overview-of-approach",
    "title": "Peaks and Pits",
    "section": "Overview of approach",
    "text": "Overview of approach\nPeaks and pits have gone through many iterations throughout the past year and a half. Currently, the general workflow is to use utilise a model framework known as SetFit to efficiently train a text classification model with limited training data. This fine-tuned model is then able to run inference over large datasets to label posts as either peaks, pits, or neither. We then utilise the LLM capabilities to refine these peak and pit moments into a collection of posts we are extremely confident are peaks and/or pits. We then employ topic modelling to identify groups of similar peaks and pits, to help us organise and discover hidden topics or themes within this collection of core moments.\nThis whole process can be split into seven distinct steps:\n\nExtract brand/product mentions from Sprinklr (the start of any project)\nObtain project-specific exemplar posts to help fine-tune a text classification model\nPerform model fine-tuning through contrastive learning\nRun inference over all of the project specific data\nUse GPT-3.5 for an extra layer of classification on identified peaks and pits\nTurn moments into something interpretable using topic modelling\n\n\n\n\nSchematic workflow from Project 706 - Peaks and Pits in M365 Apps\n\n\n\nObtain posts for the project (Step 1)\nThis step relies on the analysts to export relevant mentions from Sprinklr (one of the social listening tools that analysts utilise to obtain social data), and therefore is not detailed much here. What is required is one dataset for each of the brands/products, so they can be analysed separately.\n\n\nIdentify project-specific exemplar peaks and pits to fine-tune our ML model (Step 2)\nThis step is synonymous with data labelling required for any machine learning project where annotated data is not already available.\nThere is no perfect number of labelled examples to find per class (i.e.¬†peak, pit, or neither). Whilst in general more exemplars (and hence more training data) is beneficial, having fewer but high quality labelled posts is far superior than more posts of poorer quality. This is extremely important due to the contrastive nature of SetFit where it‚Äôs superpower is making the most of few, extremely good, labelled data.\nBy the end of this step we need to have a list of examples posts we are confident represent what a peak or pit moment looks like for each particular product we are researching, including posts that are ‚Äúneither‚Äù.\n\n\n\n\n\n\nWhy do we do this for each project? After so many projects now don‚Äôt we already have a good idea of what a peak and pit moment is for model training?\n\n\n\n\n\nEach peak and pit project we work on has the potential to introduce ‚Äòdomain‚Äô specific language, which a machine learning classifier (model) may not have seen before. By manually identifying exemplar peaks and pits that are project-specific, this gives our model the best chance to identify emotional moments appropriate to the project/data at hand.\nThe obvious case for this is with gaming specific language, where terms that don‚Äôt necessarily relate to an ‚Äòobvious‚Äô peak or pit moment could refer to one the gaming conversation, for example the terms/phrases ‚ÄúGG‚Äù, ‚Äúcamping‚Äù, ‚Äúscrub‚Äù, and ‚Äúgoat‚Äù all have very specific meanings in this domain that differ from their use in everyday language.\n\n\n\n\n\nTrain our model using our labelled examples (Step 3)\nThe SetFit documentation provides a really nice overview of SetFit‚Äôs foundational concepts, why this approach is suitable, and details the implementation process.\nBefore we begin training our SetFit model with our data, it‚Äôs necessary to clean and wrangle the fine-tuning datasets. Specifically, we need to mask any mentions of brands or products to prevent bias. For instance, if a certain brand frequently appears in the training data within peak contexts, the model could erroneously link peak moments to that brand rather than learning the peak-language expressed in the text.\n\nThis precaution should extend to all aspects of our training data that might introduce biases. For example, as we now have examples from various projects, an overrepresentation of data from ‚Äògaming projects‚Äô in our ‚Äòpeak‚Äô posts within our training set (as opposed to the ‚Äòpit‚Äô posts) could skew the model into associating gaming-related language more with peaks than pits.\n\nAt this step, we can split out our data into training, testing, and validation datasets. A good rule of thumb is to split the data 70% to training data, 15% to testing data, and 15% to validation data. By default, SetFit oversamples the minimum class within the training data, so we shouldn‚Äôt have to worry too much about imbalanced datasets- though be aware if we have extreme imbalanced we will end up sampling the same contrastive pairs (normally positive pairs) mutiple times. Indeed, our (Jamie and Aoife) experimentation has shown that class imbalance doesn‚Äôt seem to have a significant effect to the training/output of the SetFit model for peaks and pits.\nWe are now at the stage where we can actually fine-tune the model. There are many different parameters we can change when fine-tuning the model, such as the specific embedding model used, the number of epochs to train for, the number of contrastive pairs of sentences to train on etc. For more details, please refer to the Peaks and Pits Playbook\nWe can access model performance on the testing dataset by looking at accuracy, precision, recall, and F1 scores. For peaks and pits, the most important metric is actually recall because in step 6 we reclassify posts using GPT, so we want to make sure we are able to provide as many true peak/pit moments as possible to this step, even if it means we also provide a few false positives.\n\nVisualise model separation\nA bonus that can be done to check how well our model is able to separate the different classes in embedding space, is to visualise the 2-D structure of the embeddings and see how they cluster:\n\n\n\nTrained embedding model\n\n\nFor comparison, this is what it looks like on an untrained model:\n\n\n\nUntrained embedding model\n\n\nFinally, now we are happy with our model performance based on the training and validation datasets, we can evaluate the performance of this final model using our testing data. This is data that the model has never seen, and we are hoping that the accuracy and performance is similar to that of the validation data. This is Machine Learning 101 and if a refresher is needed for this there are plenty of resources online looking at the role of training, validation, and testing data.\n\n\n\nRun inference over project data (Step 4)\nIt is finally time to infer whether the project data contain peaks or pits by using our fine-tuned SetFit model to classify the posts.\nBefore doing this again we need to make sure we do some data cleaning on the project specific data.\nBroadly, this needs to match the high-level cleaning we did during fine-tuning stage:\n\nMask brand/product mentions (using RoBERTa-based model [or similar] and Rivendell functions)\nRemove hashtags #Ô∏è‚É£\nRemove mentions üí¨\nRemove URLs üåê\nRemove emojis üêô\n\n\nNote: Currently all peak and pit projects have been done on Twitter or Reddit data, but if a project includes web/forum data quirky special characters, numbered usernames, structured quotes etc should also be removed.\n\nNow we save this dataframe somewhere appropriate.\nOkay now we can finally run inference. This is extremely simple and only requires a couple of lines of code (again see the Peaks and Pits Playbook for code implementation)\nNow we have a .csv file with the probabilities each post is a peak, pit, or neither. From this we can join to our original dataframe via universal_message_id and select the classification label with the highest probability, providing us with a dataframe with all of the relevant information we need for the next steps (unviversal_message_id, message column, and peak/pit classification etc).\n\n\nThe metal detector, GPT-3.5 (Step 5)\nDuring step 4 we obtained peak and pit classification using few-shot classification with SetFit. The benefit of this approach (as outlined previously) is its speed and ability to classify with very few labelled samples due to contrastive learning.\nHowever, during our iterations of peak and pit projects, we‚Äôve realised that this step still classifies a fair amount of non-peak and pit posts incorrectly. This can cause noise in the downstream analyses and be very time consuming for us to further trudge through verbatims.\nAs such, the aim here is to further our confidence in our final list of peaks and pits to be actually peaks and pits. Remember before we explained that for SetFit, we focussed on recall being the most important measure in our business case? This is where we assume that GPT-3.5 enables us to remove the false positives due to it‚Äôs incredibly high performance.\n\nNote: Using GPT-3.5 for inference, even over relatively few posts as in peaks and pits, is expensive both in terms of time and money. Preliminary tests have suggested it is in the order of magnitude of thousands of times slower than SetFit. It is for these reasons why we do not use GPT-x models from the get go, despite it‚Äôs obvious incredible understanding of natural language.\n\nWhilst prompt-based classification such as those with GPT-3.5 certainly has its drawbacks (dependency on prompt quality, prompt injections in posts, handling and version control of complex prompts, unexpected updates to the model weights rendering prompts ineffective), the benefits include increased flexibility in what we can ask the model to do. As such, in the absence of an accurate, cheap, and quick model to perform span detection, we have found that often posts identified as peaks/pits did indeed use peak/pit language, but the context of the moment was not related to the brand/product at the core of the research project.\nFor example, take the post that we identified in the project 706, looking for peaks and pits relating to PowerPoint:\n\nThis brings me so much happiness! Being a non-binary graduate student in STEM academia can be challenging at times. Despite using my they/them pronouns during introductions, emails, powerpoint presentations, name tags, etc. my identity is continuously mistaken. Community is key!\n\nThis is clearly a ‚Äòpeak‚Äô, however it is not accurate or valid to attribute this memorable moment to PowerPoint. Indeed, PowerPoint is merely mentioned in the post, but is not a core driver of the Peak which relates to feeling connection and being part of a community. This is as much a PowerPoint Peak as it is a Peak for the use of emails.\nTherefore, we can engineer our prompt to include a caveat to say that the specific peak or pit moment must relate directly to the brand/product usage (if relevant).\n\n\nTopic modelling to make sense of our data (Step 6)\nNow we have an extremely refined set of posts classified as either peak or pits. The next step is to identify what these moments actually relate to (i.e.¬†identify the topics of these moments through statistical methods).\nTo do this, we employ topic modelling via BERTopic to identifying high-level topics that emerge within the peak and pit conversation. This is done separately for each product and peak/pit dataset (i.e.¬†there will be one BERTopic model for product A peaks, another BERTopic model for product A pits, an additional BERTopic model for product B peaks etc).\nWe implement BERTopic using the R package BertopicR. As there is already good documentation on BertopicR this section will not go into any technical detail in regards to implementation.\n\n\nThe idea\nMost of our experiences are not encoded in memory, rather what we remember about experiences are changes, significant moments, and endings",
    "crumbs": [
      "Peaks and Pits"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html#overview-of-approach-numbered",
    "href": "peaks_pits_workflow.html#overview-of-approach-numbered",
    "title": "Peaks and Pits",
    "section": "Overview of approach {numbered}",
    "text": "Overview of approach {numbered}\nPeaks and pits have gone through many iterations throughout the past year and a half. Currently, the general workflow is to use Machine Learning to label posts as either peaks or pits, before utilising LLM capabilities to refine these peak and pit moments into a collection of posts we are extremely confident are peaks and/or pits. We then utilise topic modelling to identify groups of similar peaks and pits, to help us organise and discover hidden topics or themes within this collection of peak/pit moments.\nThis whole process can be split into seven distinct steps:\n\nExtract brand/product mentions from Sprinklr (the start of any project)\nClassify a sample of posts (of each sentiment) using GPT-3.5 OR one of the latest SetFit model that has been developed (e.g.¬†the one from the previous project) to quickly identify peaks and pits\nHuman review to select exemplar peaks and pits from these ‚Äòcrudely identified posts‚Äô\nFine-tune the SetFit model using selected exemplar posts (from current project and previous projects)\nRun inference of this fine-tuned model over all of the project specific data\nUse GPT-3.5 for an extra layer of classification on identified peaks and pits\nFurther understanding the identified peak and pit moments\n\n7.a. Conduct topic modelling via BERTopic over peaks and pits separately to identify high level topics for each brand x peak/pit\n7.b. Utilize GPT-3.5 for multilabel classification of Brand Love Emotion States in peak and pit posts\n\n\n\n\n\nSchematic workflow from Project 706 - Peaks and Pits in M365 Apps\n\n\n\nStep one\n\nExtract brand/product mentions from Sprinklr (the start of any project)\n\n\n\nThe idea\nMost of our experiences are not encoded in memory, rather what we remember about experiences are changes, significant moments, and endings",
    "crumbs": [
      "Peaks and Pits"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html#openai-route",
    "href": "peaks_pits_workflow.html#openai-route",
    "title": "Peaks and Pits",
    "section": "OpenAI route",
    "text": "OpenAI route\nAfter obtaining the appropriate dataset of ~600 posts, use VS Code to ping the GPT-3.5 model API using the following script, changing the Prompt as necessary:\nimport openai\nimport pandas as pd\nimport tenacity\nimport time\nfrom openai import OpenAI\n\nfrom tenacity import retry, stop_after_attempt, wait_random_exponential, retry_if_exception_type, wait_fixed\n\ndf = pd.read_csv('path/to/sample/data/filename.csv')\n\nn = len(df)\nchunk_size = 10\nstart = 0\n\nopenai_api_key = 'OPEN_AI_KEY'\nclient = OpenAI(api_key = openai_api_key)\nretry_limit = 60\nopenai.api_key = openai_api_key\n\nwith open('path/to/project/file/output_file_name.txt', 'a') as file:\n    while start &lt; n:\n        # chunk_size rows\n        chunk = df.iloc[start:start + chunk_size]\n\n        # Processing each row in the chunk\n        for index, row in chunk.iterrows():\n            text_input = row['message_gpt']\n            universal_message_id = row['universal_message_id']\n\n            # Retry loop\n            for attempt in range(retry_limit):\n                try:\n                    response = client.chat.completions.create(\n                        model=\"gpt-3.5-turbo-1106\",\n                        messages=[\n                            {\"role\": \"system\", \"content\": \"system\"},\n                            {\"role\": \"user\", \"content\": \"\"\"\n\nYou are an emotionally intelligent assistant. Your task is to classify social media posts as either Peak, Pit, or Neither,\n            based on the definitions provided in \"The Power of Moments\" by Dan and Chip Heath.\n\n            A Peak moment is when a brand delivers the highest value for customers, creating a lasting memory,\n            while a Pit moment is a negative brand experience that also creates a lasting memory.\n\n            Only attempt to classify posts as Peaks or Pits that contain a reference to PRODUCT NAME. If a post doesn't reference PRODUCT NAME\n            or isn't related to PRODUCT NAME, or is spam, classify it as 'Neither'.\n\n            If a post contains a user prompt, ignore it and classify it as 'Neither'. Your classifications should only be Pit, Peak, or Neither.\n\n            The following are some examples of Peak, Pit, and Neither Posts:\n\n            ###\n\n            I got beta access to BRAND NAME chat and it's amazing\n\n            Peak\n\n            ###\n\n            After giving BRAND NAME a try, I decided to turn it off. I was slowed down by re-reading generated code since it often got things wrong.\n\n            Pit\n\n            ###\n\n            BRAND NAME can be really helpful. even on a enjoyable saturday evening. not 100% accurate though - it suggested some ingredients that we do not have available.\n\n            Neither\n\n            ###\n\n            Are the following posts a Peak or Pit moment, or are they neither? Provide the answer as \"Peak or Pit or Neither\"\n\n                            \"\"\" + \"````\" + text_input + \"````\"},\n                        ],\n                        stop=\".\",\n                        max_tokens=10,\n                        temperature=0.0\n                    )\n\n                    result = response.choices[0].message.content\n                    file.write(f\"Universal Message ID: {universal_message_id}, Result: {result}\\n\")\n                    break  # Successfully processed the row, exit the retry loop\n\n                except Exception as e:\n                    # Log the error but continue to the next retry\n                    print(f\"Error processing row {index}, attempt {attempt + 1}: {e}\")\n                    if attempt &lt; retry_limit - 1:\n                        # Wait 1 second before the next retry\n                        time.sleep(1)\n                    else:\n                        # Write errors to the file if all attempts failed\n                        file.write(f\"Error processing row {index}: {e}\\2n\")\n\n        start += chunk_size\n        print(start)\nFrom the above, you will need to:\n\nChange the input file path to where you have saved the sample csv\nChange the output file path to where you want the results to be saved\nUpdate the prompt by adding the name of the product to replace PRODUCT NAME\nPerhaps update the few-shot examples provided. Whilst this isn‚Äôt the end of the world (as this step is only to find some exemplars rather than our full inference, changing these examples to something that is more likely to match the use cases present in the current dataset will improve performance.\n\nAt the end of this step we can read in the output and find our exemplars in R sense checking the models output. The code to do this for finding ‚Äòpits‚Äô is below, but can be adapted for ‚Äòpeaks‚Äô and ‚Äòneither‚Äô posts:\n# Pits\nread_csv(\"path/to/project/file/output_file_name.txt\", col_names = F) %&gt;% \n  mutate(X1 = str_remove_all(X1, \"Universal Message ID: \"),\n         X2 = str_remove_all(X2, \"Result: \")) %&gt;% \n  filter(X2 == \"Pit\") %&gt;% \n  rename(universal_message_id = X1,\n         peak_pit_class = X2) %&gt;% \n  left_join(path/to/sample/data/filename.csv, by = \"universal_message_id\") %&gt;% \n  select(universal_message_id, message, sentiment)",
    "crumbs": [
      "Peaks and Pits"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html#setfit-route",
    "href": "peaks_pits_workflow.html#setfit-route",
    "title": "Peaks and Pits",
    "section": "ü§ó SetFit route",
    "text": "ü§ó SetFit route\n\nIf using a model created for project 725 or more recent, note the change at the bottom of the page\n\nWe use python based scripts or notebooks to run inference over a previously fine-tuned SetFit model (defined here as a pre-trained model that has been fine-tuned in a past project). It is recommended that Google Colab is used. The idea is that, hopefully, language between projects does not change too much so a previously created peaks and pits model should be good enough to identify exemplar peaks and pits without necessarily requiring perfect performance (because the next step has humans in the loop).\nWe can load in our previous SetFit model (note this is project specific)‚Ä¶\n# Load in libraries:\n\n!pip install datasets sentence-transformers setfit\n\n# Load previous model\nsetfit_model = SetFitModel.from_pretrained(\"path/to/previous/model\")\n‚Ä¶ and load in our sample dataset (making sure we have a key value for each document, for example universal_message_id)‚Ä¶\n# Load in libraries\nimport pandas as pd\n\n# Load in dataset\nsample_data = pd.read_csv(\"path/to/sample/data/filename.csv\")\n\n# Prepare dataset\n\n## Convert text variable to list for inference\ntext_list = sample_data['text_variable_name'].values.tolist()\n‚Ä¶ before running inference\n## Predict the probabitilies for each label for each input of the list\nprediction = model.predict_proba(text_list)\n\n## Convert prediction output to a dataframe, specifying the names of the columns\noutput_df = pd.DataFrame(prediction, columns = ['pit', 'peak', 'neither'])\n\nNote in this case the first column is pit, second column is peak, and third column is neither. For fine-tuning SetFit you provide column labels as a numeric rather than a character, and we‚Äôve been setting Pit = 0, Peak = 1, and Neither = 2, which is why that‚Äôs the order of the columns. It is highly recommended this ordering is kept in future projects to keep this consistent and avoid headaches in the future\nThis output dataframe can then have the relevant universal_message_id appended to it (as the row order of output_df should match sample_data, then be saved to a csv and uploaded on to the Drive to an appropriate location within the project folder\n## Append 'universal_message_id' column from sample_data to output_df\noutput_df['universal_message_id'] = sample_data['universal_message_id']\n\n# Save the modified output_df to a CSV file\noutput_df.to_csv(\"sample_predictions.csv\", index = False)\n!cp \"sample_predictions.csv\" \"appropriate/file/path/on/google/drive/in/project/directory/filename.csv\"\nA warning for this step is that SetFit does not work with empty strings in the input, so to account for this we can use the function sample_data = sample_data.fillna('') to convert empty strings to NA before converting to a list.\nNow we have a .csv file with the probabilities each post is a peak, pit, or neither. From this we can join to our original dataframe via universal_message_id and select the classification label with the highest probability (Argmax), providing us with a dataframe with all of the relevant information we need for the next steps (namely, universal_message_id, message, ‚Äòsentiment‚Äô, and peak/pit classification).\nNote if using a model from 725 or more recent, the SetFit code has updated so we can directly obtain output classification labels rather than obtaining probabilities and needing to use R to get the labels using Argmax\npred_labels = SETFIT_model.predict(df_text)\n\nThe idea\nMost of our experiences are not encoded in memory, rather what we remember about experiences are changes, significant moments, and endings",
    "crumbs": [
      "Peaks and Pits"
    ]
  },
  {
    "objectID": "peaks_pits_workflow.html#what-is-the-conceptproject-background",
    "href": "peaks_pits_workflow.html#what-is-the-conceptproject-background",
    "title": "Peaks and Pits",
    "section": "",
    "text": "The end goal\nWith these projects the core final ‚Äòproduct‚Äô is a collection of different peaks and pits, with suitable representative verbatims and an explanation to understand the high-level intricacies of these different emotional moments.\n\n\n\nScreenshot from a Peaks and Pits project showcasing the identified Peak moments for a product at a high level\n\n\n\n\nKey features of project\n\nThere is no out-of-the-box ML model available whose purpose is to classify social media posts as either peaks or pits (i.e.¬†we cannot use a ready-made solution, we must design our own bespoke solution).\nThere is limited data available\n\nUnlike the case of spam/ham or sentiment classification, there is not a bank of pre-labelled data available for us to leverage for ‚Äòtraditional ML‚Äô.\n\nDespite these issues, the research problem itself is well defined (what are the core peak and pit moments for a brand/product), and because there are only three classes (peak, pit, or neither) which are based on extensive research, the classes themselves are well described (even if it is case of ‚Äúyou know a peak moment when you see it‚Äù).",
    "crumbs": [
      "Peaks and Pits"
    ]
  }
]